---
sidebar_position: 4
title: Metadata
description: Column metadata annotations in sqlgg
---

# Metadata

## Why

The `[sqlgg] key=value` annotations (in SQL comments) are stored in sqlgg's schema and propagate to places where the column (or expressions derived from it) is used in DDL/DML/DQL. Code generators can then use this metadata to customize types and generated calls.

## Syntax

```
-- [sqlgg] key=value
column_name TYPE ...
```

You can write multiple metadata lines in a row.

Metadata is defined in DDL (table definitions) and automatically propagates to DML/DQL — through aliases, JOINs, and nested expressions. You only need to define it once in the schema.

At the moment these keys are consumed by the OCaml generator.

## `module=<Name>`

Associates a module used to wrap reading/writing the column value (result getters and parameter setters).

### SQL Schema

```sql
CREATE TABLE spaceships (
  -- [sqlgg] module=Ship_id
  id INT NOT NULL,
  name TEXT NOT NULL,
  -- [sqlgg] module=Light_years
  distance_from_earth DECIMAL NULL
);

-- @select_ships
SELECT id, name, distance_from_earth FROM spaceships;

-- @insert_ship
INSERT INTO spaceships (id, name, distance_from_earth) 
VALUES (@id, @name, @distance);
```

### Wrapper Modules (OCaml)

The generator expects `set_param` plus `get_column` / `get_column_nullable`.

Since files are modules in OCaml, create separate files for each wrapper. These modules must be accessible to the generated code (either in the same library or as dependencies).

**`ship_id.ml`:**
```ocaml
type t = Ship_id of int64

let set_param (Ship_id x : t) : int64 = x
let get_column (x : int64) : t = Ship_id x
let get_column_nullable (x : int64 option) : t option = Option.map get_column x
```

**`light_years.ml`:**
```ocaml
type t = Light_years of float

let set_param (Light_years x : t) : float = x
let get_column (x : float) : t = Light_years x
let get_column_nullable (x : float option) : t option = Option.map get_column x
```

### Generated Code

```ocaml
(* DO NOT EDIT MANUALLY *)
(* generated by sqlgg *)

module Make (T : Sqlgg_traits.M_io) = struct

  module IO = T.IO

  let create_spaceships db =
    T.execute db ("CREATE TABLE spaceships (\n\
    id INT NOT NULL,\n\
    name TEXT NOT NULL,\n\
    distance_from_earth DECIMAL NULL\n\
)") T.no_params

  let select_ships db callback =
    let invoke_callback stmt =
      callback
        ~id:(Ship_id.get_column (T.get_column_int64 stmt 0))
        ~name:(T.get_column_Text stmt 1)
        ~distance_from_earth:(Light_years.get_column_nullable (T.get_column_float_nullable stmt 2))
    in
    T.select db ("SELECT id, name, distance_from_earth FROM spaceships") T.no_params invoke_callback

  let insert_ship db ~id ~name ~distance =
    let set_params stmt =
      let p = T.start_params stmt 3 in
      T.set_param_int64 p (Ship_id.set_param id);
      T.set_param_Text p name;
      begin match distance with 
      | None -> T.set_param_null p 
      | Some d -> T.set_param_float p (Light_years.set_param d)
      end;
      T.finish_params p
    in
    T.execute db ("INSERT INTO spaceships (id, name, distance_from_earth) VALUES (?, ?, ?)") set_params

  module Fold = struct
    let select_ships db callback acc =
      let invoke_callback stmt =
        callback
          ~id:(Ship_id.get_column (T.get_column_int64 stmt 0))
          ~name:(T.get_column_Text stmt 1)
          ~distance_from_earth:(Light_years.get_column_nullable (T.get_column_float_nullable stmt 2))
      in
      let r_acc = ref acc in
      IO.(>>=) (T.select db ("SELECT id, name, distance_from_earth FROM spaceships") T.no_params 
        (fun x -> r_acc := invoke_callback x !r_acc))
        (fun () -> IO.return !r_acc)
  end

  module List = struct
    let select_ships db callback =
      let invoke_callback stmt =
        callback
          ~id:(Ship_id.get_column (T.get_column_int64 stmt 0))
          ~name:(T.get_column_Text stmt 1)
          ~distance_from_earth:(Light_years.get_column_nullable (T.get_column_float_nullable stmt 2))
      in
      let r_acc = ref [] in
      IO.(>>=) (T.select db ("SELECT id, name, distance_from_earth FROM spaceships") T.no_params 
        (fun x -> r_acc := invoke_callback x :: !r_acc))
        (fun () -> IO.return (List.rev !r_acc))
  end

end
```

Key points:
- `Ship_id.get_column` wraps the strict `id` column read
- `Light_years.get_column_nullable` wraps the nullable `distance_from_earth` column read
- `Ship_id.set_param` / `Light_years.set_param` wrap parameter writes
- Nullable parameters use `match` to handle `None` → `T.set_param_null`

## `non_nullifiable=true`

For `UPDATE`: once a column has been set to a non-NULL value, generated code will not allow writing `NULL` back, even if the physical column is nullable.

### Example

```sql
CREATE TABLE non_nullifiable (
  id INTEGER PRIMARY KEY,
  -- [sqlgg] non_nullifiable=true
  updated_at DATETIME NULL
);

-- @touch
UPDATE non_nullifiable SET updated_at = @updated_at WHERE id = @id;
```

In this mode sqlgg treats the assignment target as strict for updates (so `@updated_at` must be non-nullable and `SET updated_at = NULL` is rejected).

## `json_null_kind=<true|false|auto>`

Controls whether **JSON literal `null`** is treated as an allowed value for JSON-typed columns (and for `TEXT` columns when `text_as_json=true`).

### `json_null_kind` vs SQL `NULL`

SQL `NULL` means "no value"; JSON `null` is an actual JSON value that can be stored inside a JSON document. Many SQL JSON functions treat SQL `NULL` specially (often returning SQL `NULL` if any argument is SQL `NULL`), so sqlgg needs to distinguish:

- **SQL nullability** (from DDL constraints like `NOT NULL`) — whether the column can be SQL `NULL`
- **JSON nullability** (via `json_null_kind`) — whether the JSON value is allowed to be the literal `null`

### Values

- `true` / `auto` (default) — JSON `null` is allowed as a value (distinct from SQL `NULL`).
- `false` — JSON `null` is disallowed **when the column is SQL `NOT NULL`** (i.e. SQL strict). If the column itself is SQL nullable, it remains nullable regardless.

### Example

```sql
CREATE TABLE people_data_json_kind_never_null_and_col_strict (
  id INT AUTO_INCREMENT PRIMARY KEY,
  -- [sqlgg] json_null_kind=false
  data JSON NOT NULL
);
```


open ExtLib
open Sqlgg

module L = List
module S = String

(** Exception with preserved backtrace *)
exception With_backtrace of exn * Printexc.raw_backtrace

let () = Printexc.(register_printer begin function
  | With_backtrace (exn,bt) when raw_backtrace_length bt = 0 -> Some (to_string exn)
  | With_backtrace (exn,bt) -> Some (Printf.sprintf "%s\nBacktrace:\n%s" (to_string exn) (raw_backtrace_to_string bt))
  | _ -> None
end)

(** Handle parsing error and format a helpful error message *)
let handle_parsing_error sql exn (line, cnum, tok, tail) =
  let extra = match exn with
    | Sql.Schema.Error (_, msg) -> msg
    | exn -> Printexc.to_string exn
  in
  Error.log "==> %s" sql;
  if cnum = String.length sql && tok = "" then
    Error.log "Error: %s" extra
  else
    Error.log "Position %u:%u Tokens: %s%s\nError: %s" line cnum tok (String.slice ~last:32 tail) extra;
  None

let preserve_exception_context sql props exn =
  let bt = Printexc.get_raw_backtrace () in
  Error.log "Failed %s: %s" (Option.default "" @@ Props.get props "name") sql;
  let exn =
    match exn with
    | Prelude.At ((p1, p2), exn) -> 
        Error.log "At : %s" (String.slice ~first:p1 ~last:p2 sql); 
        exn
    | _ -> exn
  in
  raise @@ With_backtrace (exn, bt)

type statement_issue = 
  | UnitOutputColumn
  | UnitInputParameter of string list
  | AutogeneratedParamsWithParamsNone

let check_dialect selected sql =
  let open Dialect in
  let check_support_for_dialect ds selected_dialect =
    let { supported; unsupported; unknown } = ds.state in
    if List.mem selected_dialect supported then `Supported
    else if List.mem selected_dialect unsupported then `Unsupported
    else if List.mem selected_dialect unknown then `Unknown
    else `NotListed
  in
  List.iter
    (fun ds ->
      match check_support_for_dialect ds selected with
      | `Supported -> ()
      | `Unsupported ->
          let supported_dialects = String.concat ", " (List.map show ds.state.supported) in
          let message = 
            if ds.state.supported = [] then
              Printf.sprintf "Feature %s is not supported for dialect %s at %s"
                (show_feature ds.feature) (show selected)
                (let f, l = ds.pos in String.slice ~first:f ~last:l sql)
            else
              Printf.sprintf "Feature %s is not supported for dialect %s (supported by: %s) at %s"
                (show_feature ds.feature) (show selected) supported_dialects
                (let f, l = ds.pos in String.slice ~first:f ~last:l sql)
          in
          Error.log "%s" message
      | `Unknown when !Sqlgg_config.allow_unknown_dialect ->
          (match ds.feature with
          | Collation ->
              Error.warn "Assuming custom collation implementation for %s\n"
                (show selected)
          | _ ->
              Error.warn
                "Feature %s has unknown support for dialect %s at %s\n"
                (show_feature ds.feature) (show selected)
                (let f, l = ds.pos in String.slice ~first:f ~last:l sql))
      | `Unknown ->
          Error.log
            "Unknown dialect support for feature %s with dialect %s at %s, use -allow-unknown-dialect to proceed"
            (show_feature ds.feature) (show selected)
            (let f, l = ds.pos in String.slice ~first:f ~last:l sql)
      | `NotListed -> Error.log "Internal error: dialect not categorized properly")
    !Parser_state.Dialect_feature.state

let get_statement_error stmt sql =
  let open Sql in
  if not (Sql.Schema.is_unique stmt.Gen.schema) then
    Printf.eprintf "Warning: this SQL statement will produce rowset with duplicate column names:\n%s\n" sql;
    
  if List.exists (fun a -> Type.is_unit a.domain) stmt.schema then (
    Error.log "Output schema contains column of type Unit, which is not allowed";
    Some UnitOutputColumn
  ) else 
    let unit_params = List.filter_map 
      (function (i, Single (p, _)) when Type.is_unit p.typ -> Some (Gen.show_param_name p i) | _ -> None) 
      (List.mapi (fun i p -> i, p) stmt.vars) 
    in
    match unit_params with
    | [] -> 
        (match stmt.kind with
         | Insert (Some _, _) when !Gen.params_mode = None ->
             Error.log "Cannot use `-params none` with autogenerated parameters";
             Some AutogeneratedParamsWithParamsNone
         | _ -> None)
    | l -> 
        Error.log "Input parameter(s) of type Unit not allowed : %s" (String.concat " " l);
        Some (UnitInputParameter l)

let parse_one' (sql, props) =
    if Sqlgg_config.debug1 () then Printf.eprintf "------\n%s\n%!" sql;
    let (sql, schema, vars, kind) = Syntax.parse sql in
    begin match kind, !Gen.params_mode with
    | Insert (Some _, _), None -> Error.log "Cannot use `-params none` with autogenerated parameters"
    | _ -> ()
    end;
    let props = Props.set props "sql" sql in
    { Gen.schema; vars; kind; props }  

(** @return parsed statement or [None] in case of parsing failure.
    @raise exn for other errors (typing etc)
*)
let parse_one (sql, props as x) =
  match Props.get props "noparse" with
  | Some _ -> Some { Gen.schema=[]; vars=[]; kind=Stmt.Other; props=Props.set props "sql" sql }
  | None -> 
    try
      Some (parse_one' x)
    with
    | Parser_utils.Error (exn, (line, cnum, tok, tail)) ->
        handle_parsing_error sql exn (line, cnum, tok, tail)
    | exn ->
        preserve_exception_context sql props exn

(** Parse a select statement for sharing *)
let parse_select_one (sql, props) =
  try
    match Parser.parse_stmt sql with
    | Select select_full -> 
        check_dialect !Sqlgg_config.dialect sql;
        Shared_queries.add (Option.default "" (Props.get props "name")) (sql, select_full); 
        Some select_full
    | _ -> 
        if Sqlgg_config.debug1 () then 
          Error.log "Cannot use shared with non-select statement";
        None
  with
  | Parser_utils.Error (exn, (line, cnum, tok, tail)) ->
      handle_parsing_error sql exn (line, cnum, tok, tail)
  | exn ->
      preserve_exception_context sql props exn

(** Drop elements from an enumeration while predicate is true *)
let drop_while p e =
  while Option.map p (Enum.peek e) = Some true do
    Enum.junk e
  done  

type token = [
  | `Comment of string 
  | `Token of string 
  | `Char of char
  | `Space of string 
  | `Semicolon 
  | `Props of (string * string) list
]

module Include = struct
  type t = OnlyReusable | OnlyExecutable | ReusableAndExecutable

  let of_string = function
    | "reuse" -> OnlyReusable
    | "execute" -> OnlyExecutable
    | "reuse_and_execute"-> ReusableAndExecutable
    | s -> failwith @@ Printf.sprintf "Unknown include option %s" s

  let of_string_opt s = try (Some (of_string s))
    with Failure _ -> None
end

let extract_statement' tokens = 
    let b = Buffer.create 1024 in
    let props = ref Props.empty in
    let answer () = Buffer.contents b, !props in

    let internal_props = ref Props.empty in
    
    let rec loop smth =
      match Enum.get tokens with
      | None -> if smth then Some (answer ()) else None
      | Some x ->
        match x with
        | `Comment s -> ignore s; loop smth (* do not include comments (option?) *)
        | `Char c -> 
          if List.length !internal_props > 0 then (
            Parser_state.Stmt_metadata.add (Buffer.length b) !internal_props;
            internal_props := Props.empty;
          );
          Buffer.add_char b c; loop true
        | `Space _ when smth = false -> loop smth (* drop leading whitespaces *)
        | `Token s | `Space s -> Buffer.add_string b s; loop true
        | `Props p when smth -> internal_props := Props.set_all p !internal_props; loop smth
        | `Props p -> props := Props.set_all p !props; loop smth
        | `Semicolon -> Some (answer ())
    in
    Parser_state.next_statement();
    try loop false
    with e -> 
      Error.log "lexer failed (%s)" (Printexc.to_string e); 
      None

let get_statements ch =
  let lexbuf = Lexing.from_channel ch in
  let tokens = Enum.from (fun () ->
    if lexbuf.Lexing.lex_eof_reached then raise Enum.No_more_elements else
    match Sql_lexer.ruleStatement lexbuf with
    | `Eof -> raise Enum.No_more_elements
    | #token as x -> x)
  in
  let rec next () =
    match extract_statement' tokens with
    | None -> raise Enum.No_more_elements
    | Some (buffer, props) ->
      let include_ = match Props.get props "include" with
        | Some s -> Include.of_string s
        | None -> Include.OnlyExecutable
      in
      match include_ with
      | OnlyReusable -> 
        ignore (parse_select_one (buffer, props));
        next ();
      | OnlyExecutable -> 
        begin match parse_one (buffer, props) with
        | None -> next ()
        | Some stmt -> 
          check_dialect !Sqlgg_config.dialect buffer;
          buffer |> get_statement_error stmt |> Option.map_default (fun _ -> next ()) stmt
        end
      | ReusableAndExecutable-> 
        match parse_select_one (buffer, props) with
        | None -> next ()
        | Some select_full -> 
          let (schema, vars, kind) = Syntax.eval_select select_full in
          let stmt = { Gen.schema; vars; kind; props = Props.set props "sql" buffer } in
          buffer |> get_statement_error stmt |> Option.map_default (fun _ -> next ()) stmt
  in
  Enum.from next |> List.of_enum

let with_channel filename f =
  match try Some (open_in filename) with _ -> None with
  | None -> Error.log "cannot open file : %s" filename; f None
  | Some ch -> Std.finally (fun () -> close_in_noerr ch) f (Some ch)

open ExtLib
open Sqlgg

module L = List
module S = String

(** Exception with preserved backtrace *)
exception With_backtrace of exn * Printexc.raw_backtrace

let () = Printexc.(register_printer begin function
  | With_backtrace (exn,bt) when raw_backtrace_length bt = 0 -> Some (to_string exn)
  | With_backtrace (exn,bt) -> Some (Printf.sprintf "%s\nBacktrace:\n%s" (to_string exn) (raw_backtrace_to_string bt))
  | _ -> None
end)

(** Handle parsing error and format a helpful error message *)
let handle_parsing_error sql exn (line, cnum, tok, tail) =
  let extra = match exn with
    | Sql.Schema.Error (_, msg) -> msg
    | exn -> Printexc.to_string exn
  in
  Error.log "==> %s" sql;
  if cnum = String.length sql && tok = "" then
    Error.log "Error: %s" extra
  else
    Error.log "Position %u:%u Tokens: %s%s\nError: %s" line cnum tok (String.slice ~last:32 tail) extra;
  None

let preserve_exception_context sql props exn =
  let bt = Printexc.get_raw_backtrace () in
  Error.log "Failed %s: %s" (Option.default "" @@ Props.get props "name") sql;
  let exn =
    match exn with
    | Prelude.At ((p1, p2), exn) -> 
        Error.log "At : %s" (String.slice ~first:p1 ~last:p2 sql); 
        exn
    | _ -> exn
  in
  raise @@ With_backtrace (exn, bt)

type statement_issue = 
  | UnitOutputColumn
  | UnitInputParameter of string list
  | AutogeneratedParamsWithParamsNone

let check_dialect selected sql dialect_features =
  let open Dialect in
  let check_support_for_dialect ds selected_dialect =
    let { supported; unsupported; _ } = ds.state in
    if List.mem selected_dialect supported then `Supported
    else if List.mem selected_dialect unsupported then `Unsupported
    else `Unknown
  in
  let position_info ({ pos = (f, l); _ }: dialect_support) = String.slice ~first:f ~last:l sql in
  dialect_features |> List.iter (fun ds ->
    match check_support_for_dialect ds selected with
    | `Supported -> ()
    | `Unsupported ->
        let supported_dialects = String.concat ", " (List.map show ds.state.supported) in
        let supported_info = 
          if ds.state.supported = [] then ""
          else Printf.sprintf " (supported by: %s)" supported_dialects 
        in
        Error.log "Feature %s is not supported for dialect %s%s at %s"
          (show_feature ds.feature) (show selected) supported_info 
          (position_info ds)
    | `Unknown when List.mem ds.feature !Sqlgg_config.no_check_features ->
        (match ds.feature with
        | Collation ->
            Error.warn "Assuming custom collation implementation for %s\n"
              (show selected)
        | _ ->
            Error.warn
              "Feature %s has unknown support for dialect %s at %s\n"
              (show_feature ds.feature) (show selected) (position_info ds))
    | `Unknown ->
        Error.log
          "Unknown dialect support for feature %s with dialect %s at %s, use -no-check=all to skip all checks or -no-check=%s to skip this feature check"
          (show_feature ds.feature) (show selected) (position_info ds) (feature_to_string ds.feature))

let get_statement_error stmt sql =
  if not (Sql.Schema.is_unique stmt.Gen.schema) then
    Printf.eprintf "Warning: this SQL statement will produce rowset with duplicate column names:\n%s\n" sql;
  match stmt.kind with
  | Insert (Some _, _) when !Gen.params_mode = None ->
    Error.log "Cannot use `-params none` with autogenerated parameters";
    Some AutogeneratedParamsWithParamsNone
  | _ -> None

let parse_one' (sql, props) =
    if Sqlgg_config.debug1 () then Printf.eprintf "------\n%s\n%!" sql;
    let (sql, schema, vars, kind, dialect_features) = Syntax.parse sql in
    check_dialect !Sqlgg_config.dialect sql dialect_features;
    begin match kind, !Gen.params_mode with
    | Insert (Some _, _), None -> Error.log "Cannot use `-params none` with autogenerated parameters"
    | _ -> ()
    end;
    let props = Props.set props "sql" sql in
    { Gen.schema; vars; kind; props }

(** @return parsed statement or [None] in case of parsing failure.
    @raise exn for other errors (typing etc)
*)
let parse_one (sql, props as x) =
  match Props.get props "noparse" with
  | Some _ -> Some { Gen.schema=[]; vars=[]; kind=Stmt.Other; props=Props.set props "sql" sql }
  | None -> 
    try
      Some (parse_one' x)
    with
    | Parser_utils.Error (exn, (line, cnum, tok, tail)) ->
        handle_parsing_error sql exn (line, cnum, tok, tail)
    | exn ->
        preserve_exception_context sql props exn

(** Parse a select statement for sharing *)
let parse_select_one (sql, props) =
  try
    match Parser.parse_stmt sql with
    | { statement=Select select_full; dialect_features } -> 
        check_dialect !Sqlgg_config.dialect sql dialect_features;
        Shared_queries.add (Option.default "" (Props.get props "name")) (sql, select_full); 
        Some select_full
    | _ -> 
        if Sqlgg_config.debug1 () then 
          Error.log "Cannot use shared with non-select statement";
        None
  with
  | Parser_utils.Error (exn, (line, cnum, tok, tail)) ->
      handle_parsing_error sql exn (line, cnum, tok, tail)
  | exn ->
      preserve_exception_context sql props exn

(** Drop elements from an enumeration while predicate is true *)
let drop_while p e =
  while Option.map p (Enum.peek e) = Some true do
    Enum.junk e
  done  

type token = [
  | `Comment of string 
  | `Token of string 
  | `Char of char
  | `Space of string 
  | `Semicolon 
  | `Props of (string * string) list
]

module Include = struct
  type t = OnlyReusable | OnlyExecutable | ReusableAndExecutable

  let of_string = function
    | "reuse" -> OnlyReusable
    | "execute" -> OnlyExecutable
    | "reuse_and_execute"-> ReusableAndExecutable
    | s -> failwith @@ Printf.sprintf "Unknown include option %s" s

  let of_string_opt s = try (Some (of_string s))
    with Failure _ -> None
end

let extract_statement' tokens = 
    let b = Buffer.create 1024 in
    let props = ref Props.empty in
    let answer () = Buffer.contents b, !props in

    let internal_props = ref Props.empty in
    
    let rec loop smth =
      match Enum.get tokens with
      | None -> if smth then Some (answer ()) else None
      | Some x ->
        match x with
        | `Comment s -> ignore s; loop smth (* do not include comments (option?) *)
        | `Char c -> 
          if List.length !internal_props > 0 then (
            Parser_state.Stmt_metadata.add (Buffer.length b) !internal_props;
            internal_props := Props.empty;
          );
          Buffer.add_char b c; loop true
        | `Space _ when smth = false -> loop smth (* drop leading whitespaces *)
        | `Token s | `Space s -> Buffer.add_string b s; loop true
        | `Props p when smth -> internal_props := Props.set_all p !internal_props; loop smth
        | `Props p -> props := Props.set_all p !props; loop smth
        | `Semicolon -> Some (answer ())
    in
    Parser_state.Stmt_metadata.reset();
    try loop false
    with e -> 
      Error.log "lexer failed (%s)" (Printexc.to_string e); 
      None

let get_statements ch =
  let lexbuf = Lexing.from_channel ch in
  let tokens = Enum.from (fun () ->
    if lexbuf.Lexing.lex_eof_reached then raise Enum.No_more_elements else
    match Sql_lexer.ruleStatement lexbuf with
    | `Eof -> raise Enum.No_more_elements
    | #token as x -> x)
  in
  let rec next () =
    match extract_statement' tokens with
    | None -> raise Enum.No_more_elements
    | Some (buffer, props) ->
      let include_ = match Props.get props "include" with
        | Some s -> Include.of_string s
        | None -> Include.OnlyExecutable
      in
      match include_ with
      | OnlyReusable ->
        ignore (parse_select_one (buffer, props));
        next ();
      | OnlyExecutable -> 
        begin match parse_one (buffer, props) with
        | None -> next ()
        | Some stmt -> 
          buffer |> get_statement_error stmt |> Option.map_default (fun _ -> next ()) stmt
        end
      | ReusableAndExecutable-> 
        match parse_select_one (buffer, props) with
        | None -> next ()
        | Some select_full -> 
          let (schema, vars, kind) = Syntax.eval_select select_full in
          let stmt = { Gen.schema; vars; kind; props = Props.set props "sql" buffer } in
          buffer |> get_statement_error stmt |> Option.map_default (fun _ -> next ()) stmt
  in
  Enum.from next |> List.of_enum

let with_channel filename f =
  match try Some (open_in filename) with _ -> None with
  | None -> Error.log "cannot open file : %s" filename; f None
  | Some ch -> Std.finally (fun () -> close_in_noerr ch) f (Some ch)
